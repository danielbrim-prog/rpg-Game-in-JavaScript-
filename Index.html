<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smoother Platformer Level Editor</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { background: #87ceeb; display: block; }
    #overlay {
      position: absolute; top: 20px; left: 20px;
      color: #fff; font: bold 22px sans-serif; text-shadow: 2px 2px 6px #333;
      z-index: 10;
      pointer-events: none;
    }
    #editorBar {
      position: absolute; top: 0; left: 0; right: 0; padding: 6px 10px;
      background:rgba(0,0,0,0.8); color: #fff; font: 18px sans-serif;
      display:none; z-index:20;
    }
    #exportBox {
      position:absolute; top:40px; left:10px; z-index:30; display:none;
      background:#111; color:#fff; font:13px monospace; padding:10px; border-radius:8px;
      width:600px; height:200px; overflow:auto;
    }
  </style>
</head>
<body>
<div id="editorBar">
  <span><b>EDIT MODE</b></span>
  <span style="margin-left:30px;">[1] Platform [2] Coin [3] Enemy [4] Flag [5] Player Start</span>
  <span style="margin-left:30px;">Current: <span id="tool"></span></span>
  <span style="margin-left:30px;" id="status"></span>
  <button onclick="exportLevel()" style="margin-left:30px;">Export</button>
  <button onclick="resetLevel()">Reset Player</button>
  <button onclick="exitEdit()">Exit Edit</button>
</div>
<pre id="exportBox"></pre>
<div id="overlay"></div>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = 900;
canvas.height = 480;

const overlay = document.getElementById('overlay');
const editorBar = document.getElementById('editorBar');
const toolDisp = document.getElementById('tool');
const statusDisp = document.getElementById('status');
const exportBox = document.getElementById('exportBox');

let player, platforms, coins, enemies, flag, score, gameState, camera, levelIndex;
let editMode = false;
let editTool = 0; // 0=Platform, 1=Coin, 2=Enemy, 3=Flag, 4=PlayerStart
const toolNames = ["Platform","Coin","Enemy","Flag","Player Start"];
let selectedObj = null, dragging = false, dragOffset = [0,0], resizing = false, resizeDir = '';
let dragStart = null, dragObj = null, hoverObj = null;
let mouseX=0, mouseY=0;

// --- Levels Data ---
let levels = [
  {
    playerStart: {x: 100, y: 200},
    platforms: [
      [0, 440, 900, 50],
      [250, 380, 150, 20],
      [480, 320, 120, 20],
      [680, 270, 120, 20]
    ],
    coins: [
      {x: 280, y: 340}, {x: 510, y: 280}, {x: 710, y: 230}
    ],
    enemies: [
      {x: 540, y: 288, dir: 1, min: 480, max: 600, speed: 1.2}
    ],
    flag: {x: 800, y: 390, w: 30, h: 50}
  }
];

function rectsCollide(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}
function pointInRect(x, y, r) {
  return x >= r.x && x <= r.x+r.w && y >= r.y && y <= r.y+r.h;
}
function resetLevel() {
  const level = levels[levelIndex];
  player = {
    x: level.playerStart.x, y: level.playerStart.y, w: 36, h: 36,
    vx: 0, vy: 0,
    onGround: false,
    respawn: {x: level.playerStart.x, y: level.playerStart.y}
  };
  platforms = level.platforms.map(p => [...p]);
  coins = level.coins.map(c => ({x: c.x, y: c.y, w: 24, h: 24, taken: false}));
  enemies = level.enemies.map(e => ({
    x: e.x, y: e.y, w: 36, h: 36, dir: e.dir, min: e.min, max: e.max, speed: e.speed
  }));
  flag = level.flag ? {...level.flag} : null;
  score = 0;
  gameState = 'playing';
  camera = { x: 0, y: 0, shake: 0 };
}
function update() {
  if(gameState === 'win' || gameState === 'dead' || gameState === 'gameover' || editMode) return;
  if (keys["ArrowLeft"] || keys["KeyA"]) player.vx = -4;
  else if (keys["ArrowRight"] || keys["KeyD"]) player.vx = 4;
  else player.vx = 0;
  if ((keys["ArrowUp"] || keys["Space"] || keys["KeyW"]) && player.onGround) {
    player.vy = -12;
    player.onGround = false;
  }
  player.vy += 0.6; if (player.vy > 14) player.vy = 14;
  player.x += player.vx;
  for (let p of platforms) {
    if (rectsCollide(player, {x:p[0],y:p[1],w:p[2],h:p[3]})) {
      if (player.vx > 0) player.x = p[0] - player.w;
      if (player.vx < 0) player.x = p[0] + p[2];
    }
  }
  player.y += player.vy; player.onGround = false;
  for (let p of platforms) {
    if (rectsCollide(player, {x:p[0],y:p[1],w:p[2],h:p[3]})) {
      if (player.vy > 0) { player.y = p[1] - player.h; player.vy = 0; player.onGround = true; }
      if (player.vy < 0) { player.y = p[1] + p[3]; player.vy = 0; }
    }
  }
  for(let enemy of enemies) {
    enemy.x += enemy.speed * enemy.dir;
    if(enemy.x < enemy.min) { enemy.x = enemy.min; enemy.dir *= -1; }
    if(enemy.x > enemy.max) { enemy.x = enemy.max; enemy.dir *= -1; }
    if(rectsCollide(player, enemy)) {
      camera.shake = 12;
      gameState = 'dead';
      setTimeout(() => { resetLevel(); }, 1200);
    }
  }
  for(let coin of coins) {
    if(!coin.taken && rectsCollide(player, coin)) {
      coin.taken = true;
      score++;
    }
  }
  let allCollected = coins.every(c => c.taken);
  if(flag && allCollected && rectsCollide(player, flag)) {
    gameState = 'win';
    setTimeout(() => { resetLevel(); }, 2500);
  }
  camera.x += ((player.x - camera.x - canvas.width/2 + player.w/2) * 0.14);
  camera.x = Math.max(0, camera.x);
  if(camera.shake) { camera.x += Math.random()*camera.shake-camera.shake/2; camera.shake*=0.82; }
}
function drawResizeHandles(rect) {
  // Draw 8 handles
  let r=6;
  let xs = [rect.x, rect.x+rect.w/2, rect.x+rect.w];
  let ys = [rect.y, rect.y+rect.h/2, rect.y+rect.h];
  ctx.fillStyle = "#fff";
  for(let i=0;i<3;i++)for(let j=0;j<3;j++) {
    if((i===1&&j===1))continue;
    ctx.beginPath();
    ctx.arc(xs[i]-camera.x, ys[j], r, 0, Math.PI*2);
    ctx.fill();
  }
}
function getHandleAt(x,y,rect) {
  let r=8;
  let xs = [rect.x, rect.x+rect.w/2, rect.x+rect.w];
  let ys = [rect.y, rect.y+rect.h/2, rect.y+rect.h];
  let dirs = ['nw','n','ne','w','','e','sw','s','se'];
  let idx=0;
  for(let i=0;i<3;i++)for(let j=0;j<3;j++) {
    if(i===1&&j===1){idx++;continue;}
    let dx=xs[i]-x, dy=ys[j]-y;
    if(dx*dx+dy*dy<r*r) return dirs[idx];
    idx++;
  }
  return '';
}
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Platforms
  ctx.save();
  for (let i=0; i<platforms.length; ++i) {
    let p=platforms[i];
    ctx.fillStyle = (editMode && hoverObj && hoverObj.type==='platform' && hoverObj.idx===i) ? "#a52a2a" : "#654321";
    ctx.fillRect(p[0] - camera.x, p[1], p[2], p[3]);
    if(editMode && selectedObj && selectedObj.type==='platform' && selectedObj.idx===i) {
      ctx.strokeStyle="#0ff";ctx.lineWidth=3;
      ctx.strokeRect(p[0]-camera.x,p[1],p[2],p[3]);
      drawResizeHandles({x:p[0],y:p[1],w:p[2],h:p[3]});
    }
  }
  ctx.restore();
  // Coins
  for(let i=0; i<coins.length; ++i) {
    let coin = coins[i];
    if(!coin.taken) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(coin.x - camera.x + coin.w/2, coin.y + coin.h/2, coin.w/2, 0, Math.PI*2);
      ctx.fillStyle = (editMode && hoverObj && hoverObj.type==='coin' && hoverObj.idx===i) ? "#ffea00" : "#ffd700";
      ctx.shadowColor = "#fff";
      ctx.shadowBlur = 8; ctx.fill();
      ctx.restore();
      if(editMode && selectedObj && selectedObj.type==='coin' && selectedObj.idx===i) {
        ctx.strokeStyle="#0ff";ctx.lineWidth=3;
        ctx.beginPath();
        ctx.arc(coin.x - camera.x + coin.w/2, coin.y + coin.h/2, coin.w/2+3, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }
  // Enemies
  for(let i=0; i<enemies.length; ++i) {
    let enemy = enemies[i];
    ctx.save();
    ctx.fillStyle = (editMode && hoverObj && hoverObj.type==='enemy' && hoverObj.idx===i) ? "#ff5252" : "#d32f2f";
    ctx.fillRect(enemy.x - camera.x, enemy.y, enemy.w, enemy.h);
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(enemy.x - camera.x + enemy.w/3, enemy.y+enemy.h/2, 4, 0, Math.PI*2);
    ctx.arc(enemy.x - camera.x + enemy.w*2/3, enemy.y+enemy.h/2, 4, 0, Math.PI*2);
    ctx.fill(); ctx.restore();
    if(editMode && selectedObj && selectedObj.type==='enemy' && selectedObj.idx===i) {
      ctx.strokeStyle="#0ff";ctx.lineWidth=3;
      ctx.strokeRect(enemy.x-camera.x,enemy.y,enemy.w,enemy.h);
    }
  }
  // Flag
  if(flag){
    ctx.save();
    ctx.fillStyle = (editMode && hoverObj && hoverObj.type==='flag') ? "#cfd8dc" : "#fff";
    ctx.fillRect(flag.x - camera.x, flag.y, 8, flag.h);
    ctx.beginPath();
    ctx.moveTo(flag.x - camera.x + 8, flag.y+10);
    ctx.lineTo(flag.x - camera.x + 38, flag.y+24);
    ctx.lineTo(flag.x - camera.x + 8, flag.y+38);
    ctx.closePath();
    ctx.fillStyle = "#3f51b5"; ctx.fill();
    ctx.restore();
    if(editMode && selectedObj && selectedObj.type==='flag') {
      ctx.strokeStyle="#0ff";ctx.lineWidth=3;
      ctx.strokeRect(flag.x-camera.x,flag.y,flag.w,flag.h);
    }
  }
  // Player Start
  if(editMode && toolDisp) {
    let ps=levels[levelIndex].playerStart;
    ctx.save();
    ctx.fillStyle = "#00c853";
    ctx.globalAlpha=0.5;
    ctx.fillRect(ps.x-camera.x,ps.y,36,36);
    ctx.globalAlpha=1;
    ctx.strokeStyle="#fff";ctx.lineWidth=2;
    ctx.strokeRect(ps.x-camera.x,ps.y,36,36);
    ctx.restore();
    if(selectedObj && selectedObj.type==='playerStart') {
      ctx.strokeStyle="#0ff";ctx.lineWidth=3;
      ctx.strokeRect(ps.x-camera.x,ps.y,36,36);
    }
  }
  // Player
  ctx.save();
  ctx.fillStyle = "#00c853";
  ctx.fillRect(player.x - camera.x, player.y, player.w, player.h);
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(player.x - camera.x + player.w/2, player.y + player.h/2, 7, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(player.x - camera.x + player.w/2 -3, player.y + player.h/2 -2, 2, 0, Math.PI*2);
  ctx.arc(player.x - camera.x + player.w/2 +3, player.y + player.h/2 -2, 2, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Draw drag platform preview
  if(editMode && editTool==0 && dragObj){
    let [x0,y0]=dragStart, [x1,y1]=dragObj;
    ctx.strokeStyle="#4fc3f7";ctx.lineWidth=2;
    ctx.strokeRect(Math.min(x0,x1)-camera.x, Math.min(y0,y1), Math.abs(x1-x0), Math.abs(y1-y0));
  }
}
function renderOverlay() {
  let allCollected = coins.every(c => c.taken);
  let msg = '';
  if(editMode) msg = 'EDIT MODE (E to exit)';
  else if(gameState==='win')
    msg = "Level Complete!";
  else if(gameState==='dead')
    msg = "Oops! You touched an enemy. Restarting...";
  else if(gameState==='gameover')
    msg = "You beat all levels! Restarting...";
  else
    msg = `Coins: ${score} / ${coins.length}` + (allCollected ? " â€” Go to the flag!" : "");
  overlay.innerText = msg;
}

function loop() {
  update();
  draw();
  renderOverlay();
  requestAnimationFrame(loop);
}

// --- Controls & Editor ---
let keys = {};
window.addEventListener('keydown', (e) => {
  if(document.activeElement === exportBox) return;
  keys[e.code] = true;
  if(e.code==="KeyE") {
    if(!editMode) enterEdit();
    else exitEdit();
  }
  if(editMode) {
    if(e.code==="Digit1") editTool=0;
    if(e.code==="Digit2") editTool=1;
    if(e.code==="Digit3") editTool=2;
    if(e.code==="Digit4") editTool=3;
    if(e.code==="Digit5") editTool=4;
    toolDisp.textContent=toolNames[editTool];
  }
  if(editMode && selectedObj && (e.code==="Delete"||e.code==="Backspace")) {
    // Delete selected obj
    if(selectedObj.type==='platform') { platforms.splice(selectedObj.idx,1);}
    if(selectedObj.type==='coin') { coins.splice(selectedObj.idx,1);}
    if(selectedObj.type==='enemy') { enemies.splice(selectedObj.idx,1);}
    if(selectedObj.type==='flag') { flag=null;}
    if(selectedObj.type==='playerStart'){} // can't delete
    selectedObj=null;
    updateAndResetLevelFromEditor();
  }
});
window.addEventListener('keyup', e => keys[e.code] = false);

function enterEdit() {
  editMode = true;
  editorBar.style.display = "block";
  toolDisp.textContent = toolNames[editTool];
  statusDisp.textContent = "";
}
function exitEdit() {
  editMode = false;
  editorBar.style.display = "none";
  exportBox.style.display = "none";
  selectedObj = null;
}
function updateAndResetLevelFromEditor() {
  let lvl = levels[levelIndex];
  lvl.platforms = platforms.map(p=>[Math.round(p[0]),Math.round(p[1]),Math.round(p[2]),Math.round(p[3])]);
  lvl.coins = coins.map(c=>({x:Math.round(c.x),y:Math.round(c.y)}));
  lvl.enemies = enemies.map(e=>({x:Math.round(e.x),y:Math.round(e.y),dir:1,min:Math.round(e.min),max:Math.round(e.max),speed:e.speed}));
  lvl.flag = flag ? {...flag} : undefined;
  resetLevel();
}
canvas.addEventListener('mousemove', (e) => {
  if(!editMode) return;
  const rect = canvas.getBoundingClientRect();
  mouseX = Math.floor(e.clientX - rect.left + camera.x);
  mouseY = Math.floor(e.clientY - rect.top);
  hoverObj = null;
  // Find object under mouse
  // Priority: resize handles > selected > platform > coin > enemy > flag > playerStart
  if(selectedObj && selectedObj.type==='platform') {
    let p=platforms[selectedObj.idx];
    let dir = getHandleAt(mouseX,mouseY,{x:p[0],y:p[1],w:p[2],h:p[3]});
    if(dir) { statusDisp.textContent="Resize: "+dir; hoverObj = {type:'platform', idx:selectedObj.idx}; return;}
  }
  // Platforms
  for(let i=0;i<platforms.length;++i){
    let p=platforms[i];
    if(pointInRect(mouseX,mouseY,{x:p[0],y:p[1],w:p[2],h:p[3]})){ hoverObj={type:'platform',idx:i}; return;}
  }
  // Coins
  for(let i=0;i<coins.length;++i){
    let c=coins[i];
    if(pointInRect(mouseX,mouseY,{x:c.x,y:c.y,w:c.w,h:c.h})){ hoverObj={type:'coin',idx:i}; return;}
  }
  // Enemies
  for(let i=0;i<enemies.length;++i){
    let en=enemies[i];
    if(pointInRect(mouseX,mouseY,{x:en.x,y:en.y,w:en.w,h:en.h})){ hoverObj={type:'enemy',idx:i}; return;}
  }
  // Flag
  if(flag && pointInRect(mouseX,mouseY,flag)){ hoverObj={type:'flag'}; return;}
  // Player start
  let ps=levels[levelIndex].playerStart;
  if(editTool===4 && pointInRect(mouseX,mouseY,{x:ps.x,y:ps.y,w:36,h:36})){ hoverObj={type:'playerStart'}; return;}
});
canvas.addEventListener('mousedown', (e) => {
  if(!editMode) return;
  const rect = canvas.getBoundingClientRect();
  let x = Math.floor(e.clientX - rect.left + camera.x);
  let y = Math.floor(e.clientY - rect.top);
  let handled = false;
  // Drag/resize logic
  if(hoverObj && hoverObj.type==='platform' && selectedObj && selectedObj.type==='platform' && selectedObj.idx===hoverObj.idx) {
    let p=platforms[selectedObj.idx];
    let dir = getHandleAt(x,y,{x:p[0],y:p[1],w:p[2],h:p[3]});
    if(dir) { resizing=true; resizeDir=dir; dragOffset=[x-p[0],y-p[1]]; handled=true;}
    else { dragging=true; dragOffset=[x-p[0],y-p[1]]; }
  }
  if(!handled && hoverObj){
    selectedObj = {...hoverObj};
    if(hoverObj.type==='platform') { dragging=true; dragOffset=[x-platforms[hoverObj.idx][0],y-platforms[hoverObj.idx][1]];}
    if(hoverObj.type==='coin') { dragging=true; dragOffset=[x-coins[hoverObj.idx].x,y-coins[hoverObj.idx].y];}
    if(hoverObj.type==='enemy') { dragging=true; dragOffset=[x-enemies[hoverObj.idx].x,y-enemies[hoverObj.idx].y];}
    if(hoverObj.type==='flag') { dragging=true; dragOffset=[x-flag.x,y-flag.y];}
    if(hoverObj.type==='playerStart') { dragging=true; dragOffset=[x-levels[levelIndex].playerStart.x,y-levels[levelIndex].playerStart.y];}
    handled=true;
  }
  if(!handled) {
    selectedObj=null;
    // Placing new
    if(editTool===0) { dragStart = [x,y]; dragObj=[x,y]; }
    if(editTool===1) { coins.push({x:x-12,y:y-12,w:24,h:24,taken:false}); updateAndResetLevelFromEditor();}
    if(editTool===2) { enemies.push({x:x-18,y:y-18,w:36,h:36,dir:1,min:x-30,max:x+30,speed:1.5}); updateAndResetLevelFromEditor();}
    if(editTool===3) { flag={x:x-15,y:y-25,w:30,h:50}; updateAndResetLevelFromEditor();}
    if(editTool===4) { levels[levelIndex].playerStart={x:x-18,y:y-18}; updateAndResetLevelFromEditor();}
  }
});
canvas.addEventListener('mousemove', (e) => {
  if(!editMode) return;
  const rect = canvas.getBoundingClientRect();
  let x = Math.floor(e.clientX - rect.left + camera.x);
  let y = Math.floor(e.clientY - rect.top);
  if(resizing && selectedObj && selectedObj.type==='platform') {
    let p=platforms[selectedObj.idx];
    let ox=p[0],oy=p[1],ow=p[2],oh=p[3];
    let minw=20,minh=20;
    if(resizeDir.includes('n')) { oh+=(oy-y); oy=y; if(oh<minh){oy=oy+oh-minh;oh=minh;} }
    if(resizeDir.includes('s')) { oh=y-oy; if(oh<minh)oh=minh;}
    if(resizeDir.includes('w')) { ow+=(ox-x); ox=x; if(ow<minw){ox=ox+ow-minw;ow=minw;} }
    if(resizeDir.includes('e')) { ow=x-ox; if(ow<minw)ow=minw;}
    platforms[selectedObj.idx]=[ox,oy,ow,oh];
    updateAndResetLevelFromEditor();
  }
  else if(dragging && selectedObj) {
    if(selectedObj.type==='platform') {
      let p=platforms[selectedObj.idx];
      p[0]=x-dragOffset[0];p[1]=y-dragOffset[1];
      updateAndResetLevelFromEditor();
    }
    if(selectedObj.type==='coin') {
      let c=coins[selectedObj.idx];
      c.x=x-dragOffset[0];c.y=y-dragOffset[1];
      updateAndResetLevelFromEditor();
    }
    if(selectedObj.type==='enemy') {
      let en=enemies[selectedObj.idx];
      en.x=x-dragOffset[0];en.y=y-dragOffset[1];
      en.min=en.x-30;en.max=en.x+30;
      updateAndResetLevelFromEditor();
    }
    if(selectedObj.type==='flag') {
      flag.x=x-dragOffset[0];flag.y=y-dragOffset[1];
      updateAndResetLevelFromEditor();
    }
    if(selectedObj.type==='playerStart') {
      levels[levelIndex].playerStart.x=x-dragOffset[0];levels[levelIndex].playerStart.y=y-dragOffset[1];
      updateAndResetLevelFromEditor();
    }
  }
  if(editTool===0 && dragStart) {
    dragObj=[x,y];
  }
});
canvas.addEventListener('mouseup', (e) => {
  if(!editMode) return;
  resizing=false; dragging=false;
  if(editTool===0 && dragStart && dragObj){
    let [x0,y0]=dragStart, [x1,y1]=dragObj;
    let minw=20,minh=20;
    let w=Math.abs(x1-x0),h=Math.abs(y1-y0);
    if(w>=minw&&h>=minh)
      platforms.push([Math.min(x0,x1), Math.min(y0,y1), w, h]);
    dragStart = null; dragObj = null;
    updateAndResetLevelFromEditor();
  }
});
canvas.addEventListener('contextmenu', (e) => {
  if(!editMode) return (e.preventDefault(),false);
  const rect = canvas.getBoundingClientRect();
  let x = Math.floor(e.clientX - rect.left + camera.x);
  let y = Math.floor(e.clientY - rect.top);
  if(hoverObj){
    if(hoverObj.type==='platform') { platforms.splice(hoverObj.idx,1); updateAndResetLevelFromEditor(); }
    if(hoverObj.type==='coin') { coins.splice(hoverObj.idx,1); updateAndResetLevelFromEditor(); }
    if(hoverObj.type==='enemy') { enemies.splice(hoverObj.idx,1); updateAndResetLevelFromEditor(); }
    if(hoverObj.type==='flag') { flag=null; updateAndResetLevelFromEditor(); }
  }
  return false;
});

function exportLevel() {
  const out = {
    playerStart: {...levels[levelIndex].playerStart},
    platforms: platforms.map(p=>[Math.round(p[0]),Math.round(p[1]),Math.round(p[2]),Math.round(p[3])]),
    coins: coins.map(c=>({x:Math.round(c.x),y:Math.round(c.y)})),
    enemies: enemies.map(e=>({x:Math.round(e.x),y:Math.round(e.y),dir:1,min:Math.round(e.min),max:Math.round(e.max),speed:e.speed})),
    flag: flag ? {...flag} : undefined
  };
  exportBox.textContent = JSON.stringify(out,null,2);
  exportBox.style.display = "block";
}

function importLevel(json) {
  try {
    let lvl = JSON.parse(json);
    levels[levelIndex] = lvl;
    resetLevel();
    exitEdit();
  } catch(e) { alert("Import failed!"); }
}

// --- Start Game ---
levelIndex = 0;
resetLevel();
loop();
</script>
</body>
</html>
